// Imports.
// Imports.
include "getARGV.idp";

// Load mesh.
mesh Th = readmesh("/home/julian/Repos/convex-calderon/mesh/Th1_20.msh");
fespace Vh(Th, P1);

// Generate boundary conditions.
int D = getARGV("-D", 20);
int nbc = getARGV("-bc", 20);
Vh[int] bcs(2 * nbc);
for (int j = 0; j < nbc; j++){
  bcs[j] = sin( (nbc - j) * atan2(y, x) ) / sqrt( pi );
  bcs[j + nbc] = cos( ( j + 1 ) * atan2(y, x) ) / sqrt( pi );
}

// Load conductivities.
Vh sigma = 0.0;
real dtheta = pi / 3;
real eps = 1e-3;
Vh theta = pi - atan2(y, -x);
for (int j = 0; j < 6; j++){
  real sj = getARGV("-s" + j, j + 1.0);
  Vh dsj = sj * ( j * dtheta - eps <= theta) * (theta < ( j + 1 ) * dtheta - eps);
  sigma = sigma + dsj;
}
// plot(sigma, wait = true, fill = true);

// Stiffness matrix.
varf a(u, v) = int2d(Th)( sigma * ( dx(u)*dx(v) + dy(u)*dy(v) ) );
matrix A = a(Vh, Vh);
set(A, solver = sparsesolver);

func matrix fntd() {
  real[int, int] ntd(2 * nbc, 2 * nbc);
  Vh[int] solutions( 2 * nbc );
  for (int j = 0; j < 2 * nbc; j++){
    varf l(unused, v) = int1d(Th, D-1)( bcs[j] * v );
    real[int] f = l(0, Vh);
    solutions[j][] = A^-1 * f;
    // plot(solutions[j], fill = true, value = false, wait = false, nbiso = 200);
    for (int k = 0; k < 2 * nbc; k++){
      if ( k >= j ){
        ntd(j, k) = int1d(Th, D - 1)( solutions[j] * bcs[k] );
      } else {
        ntd(j, k) = ntd(k, j);
      }
    }
  }
  matrix rntd = ntd;
  return rntd;
}

matrix mntd = fntd();
cout << mntd << endl;
