// Imports.
include "getARGV.idp"
load "lapack"

// Load parameters.
int D = getARGV("-bc", 20);
int nbc = getARGV("-bc", 20);

// Include additional scripts.
include "utils/mesh.edp"
include "utils/boundary_basis.edp"
include "utils/conductivity_mask.edp"
include "utils/linear_algebra.edp"

// Set variational form.
varf a(u, v) = int2d(Th)( sigma0 * ( dx(u)*dx(v) + dy(u)*dy(v) ) );
matrix A = a(Vh, Vh);
set(A, solver = sparsesolver);
set(A, sparams = "-pc_type cholesky -pc_factor_mat_solver_type mumps -mat_mumps_icntl_33 1 -ksp_view");

// Compute solutions for each boundary condition.
Vh[int] dxs(2 * nbc);
Vh[int] dys(2 * nbc);
Vh temp = 0.0;
for (int j = 0; j < 2 * nbc; j++){
  varf l(unused, v) = int1d(Th, D-1)( bcs[j] * v );
  real[int] f = l(0, Vh);
  temp[] = A^-1 * f;
  dxs[j] = dx(temp);
  dys[j] = dy(temp);
}

// Compute crossed products of solutions.
Vh[int] Dxs(4 * nbc ^ 2);
Vh[int] Dys(4 * nbc ^ 2);
for (int idx = mpirank; idx <= ( 2 * nbc + 1 ) * ( 2 * nbc - 1 ) ; idx += mpisize) {
  int j = idx / ( 2 * nbc );
  int k = idx % ( 2 * nbc );
  if ( k >= j ) {
    Dxs[idx] = dxs[j] * dxs[k];
    Dys[idx] = dys[j] * dys[k];
  }
}

// Broadcast crossed products.
for (int idx = 0; idx <= ( 2 * nbc + 1 ) * ( 2 * nbc - 1 ) ; idx++) {
  int rnk = idx % mpisize;
  broadcast(processor(rnk), Dxs[idx][]);
  broadcast(processor(rnk), Dys[idx][]);
}

// Compute the gradient.
matrix[int] gradient(6);
matrix di(2 * nbc, 2 * nbc );
for (int j = 0; j < 2 * nbc; j++){
  for (int k = 0; k < 2 * nbc; k++){
    di(j, k) = 0.0;
    if ( k >= j ){
      int idx = 2 * nbc * j + k;
      di(j, k) = -int2d(Th)( masks[mpirank] * ( Dxs[idx] + Dys[idx] ));
    } else {
      di(j, k) = di(k, j);
    }
  }
}
gradient[mpirank] = di;

// Sent di to other cores.
for (int j = 0; j < 6; j++) {
  broadcast(processor(j), gradient[j]);
}

