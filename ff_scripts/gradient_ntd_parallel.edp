// Imports.
include "getARGV.idp"

// Load mesh.
int D = getARGV("-D", 20);
mesh Th = readmesh("/home/julian/Repos/convex-calderon/mesh/Th1_20.msh");
fespace Vh(Th, P1);

// Generate boundary conditions.
int nbc = getARGV("-bc", D);
Vh[int] bcs(2 * nbc);
for (int j = mpirank; j < nbc; j += mpisize) {
  bcs[j] = sin( (nbc - j) * atan2(y, x) ) / sqrt( pi );
  bcs[j + nbc] = cos( ( j + 1 ) * atan2(y, x) ) / sqrt( pi );
}

for (int j = 0; j < nbc; j++) {
  int rnk = j % mpisize;
  broadcast(processor(rnk), bcs[j][]);
  broadcast(processor(rnk), bcs[j + nbc][]);
}

// Generate masks.
Vh[int] masks(6);
Vh theta = pi - atan2(y, -x);
real dtheta = pi / 3;
real eps = 1e-3;
Vh sigma = 0;
for (int j = 0; j < 6; j++){
  real sj = getARGV("-s" + j, j + 1);
  masks[j] = ( j * dtheta - eps <= theta) * (theta < ( j + 1 ) * dtheta - eps);
  sigma = sigma + sj * masks[j];
}

// Set variational form.
varf a(u, v) = int2d(Th)( sigma * ( dx(u)*dx(v) + dy(u)*dy(v) ) );
matrix A = a(Vh, Vh);
set(A, solver = sparsesolver);

// Compute solutions for each boundary condition.
Vh[int] dxs(2 * nbc);
Vh[int] dys(2 * nbc);
Vh temp = 0.0;
for (int j = 0; j < 2 * nbc; j++){
  varf l(unused, v) = int1d(Th, D-1)( bcs[j] * v );
  real[int] f = l(0, Vh);
  temp[] = A^-1 * f;
  dxs[j] = dx(temp);
  dys[j] = dy(temp);
}

// Compute crossed products of solutions.
Vh[int] Dxs(4 * nbc ^ 2);
Vh[int] Dys(4 * nbc ^ 2);
for (int idx = mpirank; idx <= ( 2 * nbc + 1 ) * ( 2 * nbc - 1 ) ; idx += mpisize) {
  int j = idx / ( 2 * nbc );
  int k = idx % ( 2 * nbc );
  if ( k >= j ) {
    Dxs[idx] = dxs[j] * dxs[k];
    Dys[idx] = dys[j] * dys[k];
  }
}

// Broadcast crossed products.
for (int idx = 0; idx <= ( 2 * nbc + 1 ) * ( 2 * nbc - 1 ) ; idx++) {
  int rnk = idx % mpisize;
  broadcast(processor(rnk), Dxs[idx][]);
  broadcast(processor(rnk), Dys[idx][]);
}

// Compute the gradient.
matrix[int] gradient(6);
matrix di(2 * nbc, 2 * nbc );
for (int j = 0; j < 2 * nbc; j++){
  for (int k = 0; k < 2 * nbc; k++){
    di(j, k) = 0.0;
    if ( k >= j ){
      int idx = 2 * nbc * j + k;
      di(j, k) = -int2d(Th)( masks[mpirank] * ( Dxs[idx] + Dys[idx] ));
    } else {
      di(j, k) = di(k, j);
    }
  }
}
gradient[mpirank] = di;

// Sent di to other cores.
for (int j = 0; j < 6; j++) {
  broadcast(processor(j), gradient[j]);
}

if ( mpirank == 0 ) {
  for (int j = 0; j < 6; j++) {
    cout << gradient[j] << endl;
  }
}
